/* shuffles contents then deshuffles based on key value preforms transformations after shuffle */

#include <time.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "header.h"

#define ROTATE_BLOCK_LEFT(block, pos) (((block) << (pos)) | ((block) >> (32 - (pos))))
#define ROTATE_BLOCK_RIGHT(block, pos) (((block) >> (pos)) | ((block) << (32 - (pos))))

static uint32_t ShuffleBlock(uint32_t block, uint8_t key) {
    uint8_t key_mod = key % sizeof(uint32_t);

#ifdef FURTHER_ROTATION
    block = ROTATE_BLOCK_RIGHT(block, (key | 0b11000111) % 32);
    block = ROTATE_BLOCK_LEFT(block, (key | 0b11100011) % 32);
    block = ROTATE_BLOCK_RIGHT(block, (key | 0b01101111) % 32);
    block = ROTATE_BLOCK_LEFT(block, (key | 0b11110000) % 32);
    block = ROTATE_BLOCK_RIGHT(block, (key | 0b10101010) % 32);
#endif

    for(int i = 0; i < key_mod; i++) {
        block = ROTATE_BLOCK_LEFT(block, 8);
    }

    block = ROTATE_BLOCK_RIGHT(block, key % 32);
    block = ROTATE_BLOCK_LEFT(block, ~key % 32);

    return block;
}

static uint32_t UnshuffleBlock(uint32_t block, uint8_t key) {
    uint8_t key_mod = key % sizeof(uint32_t);

    block = ROTATE_BLOCK_RIGHT(block, ~key % 32);
    block = ROTATE_BLOCK_LEFT(block, key % 32);

    for(int i = 0; i < key_mod; i++) {
        block = ROTATE_BLOCK_RIGHT(block, 8);
    }

#ifdef FURTHER_ROTATION
    block = ROTATE_BLOCK_LEFT(block, (key | 0b10101010) % 32);
    block = ROTATE_BLOCK_RIGHT(block, (key | 0b11110000) % 32);
    block = ROTATE_BLOCK_LEFT(block, (key | 0b01101111) % 32);
    block = ROTATE_BLOCK_RIGHT(block, (key | 0b11100011) % 32);
    block = ROTATE_BLOCK_LEFT(block, (key | 0b11000111) % 32);
#endif

    return block;
}

static void Encrypt(uint8_t *bytes, enc_ctx_t *ctx) {
    uint8_t *block_bytes = bytes;
    uint32_t *byte_arr = (uint32_t *)bytes;

    /* preform transformations */

    uint32_t seed = 0b01010101; /* even bits seemed like it would work best */
    uint8_t *seed_bytes = (uint8_t *)&seed;

    for(size_t i = 0; i < ctx->bytes_len; i++) {
        uint8_t byte = bytes[i];
        uint8_t key_byte = ctx->key[i % ctx->key_len];

        /* note seed isnt reset to zero which further obfuscates the bytes */
        /* alter seed value */

        seed_bytes[0] = (seed_bytes[1] + key_byte) % 0xff;
        seed_bytes[1] = (seed_bytes[2] + key_byte) % 0xff;   
        seed_bytes[2] = (seed_bytes[3] + key_byte) % 0xff;
        seed_bytes[3] = (seed_bytes[0] + key_byte) % 0xff; 

        /* calculate seed value */ 

        seed ^= (uint8_t)((key_byte ^ ((0xff + key_byte) % 0xff)) | i) & 0xff;
        seed <<= 8;
        seed ^= (uint8_t)((key_byte ^ ((0xaa * (key_byte << 16)) % 0xff)) | i) & 0xff;
        seed <<= 8;
        seed ^= (uint8_t)((key_byte ^ ((0xcc * ((key_byte * 2) << 16)) % 0xff)) | i) & 0xff;
        seed <<= 8;
        seed ^= (uint8_t)((key_byte ^ ((0xdd * ((key_byte + (0xff / 2)) << 8)) % 0xff)) | i) & 0xff;

        /* xor generated bytes */

        byte ^= key_byte;
        
        byte ^= (uint8_t)(seed & 0xff); 
        byte ^= (uint8_t)((seed >> 8) & 0xff);
        byte ^= (uint8_t)((seed >> 16) & 0xff);
        byte ^= (uint8_t)((seed >> 24) & 0xff);

        seed = ROTATE_BLOCK_LEFT(seed, seed % 32);

        byte ^= (uint8_t)(seed & 0xff); 
        byte ^= (uint8_t)((seed >> 8) & 0xff);
        byte ^= (uint8_t)((seed >> 16) & 0xff);
        byte ^= (uint8_t)((seed >> 24) & 0xff);

        bytes[i] = byte;
    }

    /* shuffle every 32 bits */
    
    size_t count = 0;
    while(*byte_arr) {
        *byte_arr = ShuffleBlock(*byte_arr, ctx->key[count % ctx->key_len]);
        *byte_arr++, count++;
    }
}

static void Decrypt(uint8_t *bytes, enc_ctx_t *ctx) {
    uint8_t *block_bytes = bytes;
    uint32_t *byte_arr = (uint32_t *)bytes;

    /* unshuffle every 32 bits */

    size_t count = 0;
    while(*byte_arr) {
        *byte_arr = UnshuffleBlock(*byte_arr, ctx->key[count % ctx->key_len]);
        *byte_arr++, count++;
    }
    
    /* preform transformations */
    uint32_t seed = 0;
    uint8_t *seed_bytes = (uint8_t *)&seed;

    for(size_t i = 0; i < ctx->bytes_len; i++) {
        uint8_t byte = bytes[i];
        uint8_t key_byte = ctx->key[i % ctx->key_len];

        /* note seed isnt reset to zero which further obfuscates the bytes */
        /* alter seed value */

        seed_bytes[0] = (seed_bytes[1] + key_byte) % 0xff;
        seed_bytes[1] = (seed_bytes[2] + key_byte) % 0xff;   
        seed_bytes[2] = (seed_bytes[3] + key_byte) % 0xff;
        seed_bytes[3] = (seed_bytes[0] + key_byte) % 0xff; 

        /* calculate seed value */ 

        seed ^= (uint8_t)((key_byte ^ ((0xff + key_byte) % 0xff)) | i) & 0xff;
        seed <<= 8;
        seed ^= (uint8_t)((key_byte ^ ((0xaa * (key_byte << 16)) % 0xff)) | i) & 0xff;
        seed <<= 8;
        seed ^= (uint8_t)((key_byte ^ ((0xcc * ((key_byte * 2) << 16)) % 0xff)) | i) & 0xff;
        seed <<= 8;
        seed ^= (uint8_t)((key_byte ^ ((0xdd * ((key_byte + (0xff / 2)) << 8)) % 0xff)) | i) & 0xff;

        /* xor generated bytes */

        byte ^= key_byte;
        
        byte ^= (uint8_t)(seed & 0xff); 
        byte ^= (uint8_t)((seed >> 8) & 0xff);
        byte ^= (uint8_t)((seed >> 16) & 0xff);
        byte ^= (uint8_t)((seed >> 24) & 0xff);

        seed = ROTATE_BLOCK_LEFT(seed, seed % 32);

        byte ^= (uint8_t)(seed & 0xff); 
        byte ^= (uint8_t)((seed >> 8) & 0xff);
        byte ^= (uint8_t)((seed >> 16) & 0xff);
        byte ^= (uint8_t)((seed >> 24) & 0xff);

        bytes[i] = byte;
    }
}

void print_binary(uint8_t byte) {
    for (int i = 7; i >= 0; i--) {
        printf("%c", (byte & (1 << i)) ? '1' : '0');
    }
}

int main(int argc, char **argv) {
    size_t key_len = atoi(argv[2]);
    size_t len = strlen(argv[1]);
    char *str = calloc(1, len + 1);
    uint8_t *key = calloc(1, key_len);
    
    memcpy(str, argv[1], len);
    
    srand(time(NULL) | getpid() << 24);
    
    for(int i = 0; i < key_len; i++)
        key[i] = rand() % 0xff;

    printf("Using key %s len %zu\r\n", key, key_len);

    for(int i = 0; i < key_len; i++)
        printf("\\x%02x", ((uint8_t *)key)[i]);

    printf("\r\n\r\nOriginal %s\r\nHex ", str);

    for(size_t i = 0; i < len; i++)
        printf("\\x%02x", ((unsigned char *)str)[i]);
    printf("\r\nBinary ");
    for(size_t i = 0; i < len; i++) {
        print_binary(str[i]);
        printf(" ");
    }

    printf("\r\n\r\n");
    
    Encrypt(str, &(enc_ctx_t){
        .key = (uint8_t *)&key,
        .key_len = key_len,
        .bytes_len = len,
    });

    printf("Encrypted %s\r\nHex ", str);

    for(size_t i = 0; i < len; i++)
        printf("\\x%02x", ((unsigned char *)str)[i]);
    printf("\r\nBinary ");
    for(size_t i = 0; i < len; i++) {
        print_binary(str[i]);
        printf(" ");
    }

    printf("\r\n\r\n");

    Decrypt(str, &(enc_ctx_t){
        .key = (uint8_t *)&key,
        .key_len = key_len,
        .bytes_len = len,
    });

    printf("Decrypted %s\r\nHex ", str);

    for(size_t i = 0; i < len; i++)
        printf("\\x%02x", ((unsigned char *)str)[i]);
    printf("\r\nBinary ");
    for(size_t i = 0; i < len; i++) {
        print_binary(str[i]);
        printf(" ");
    }

    printf("\r\n");
}
